#一、哈夫曼树

##合并果子问题

* 描述：
  有n堆果子，需要合并成一堆，每次只能合并其中两堆，每次合并消耗的体力为这两堆果子的质量和（没堆果子的质量已知），求最节省体力的方案所消耗的体力值。


* 分析：
  1. 合并两堆果子可以视作生成一个父结点，父结点的权值（体力值==质量值）等于他们的质量和
  2. **最终消耗的体力之和 =∑(叶子结点n的权值 × 叶子结点n到根结点的路径长度)**
   即这棵树的带权路径长度


* 注意：最终根节点的权值只是总质量，不等于带权路径长度，**它是小于带权路径长度的！！**

* 叶子结点的带权路径长度：结点权值 × 路径长度
* 
* 树的带权路径长度：所有**叶子结点**的带权路径长度之和


* **果子问题转化为：**
  给定n个数作为叶子结点的权值，求一棵带权路径长度最小的（二叉）树（不唯一，但最小带权路径长度唯一），也就是求它的一棵哈夫曼树


* **哈夫曼树：**带权路径长度最小的树，也称为最优二叉树
  * 性质：不存在度为1的结点

##解决（但是带权路径长度很容易算错，不能直接取最后一个唯一的堆顶元素输出）

* 思路很简单：每次总是合并权值最小的两堆

* 使用**小顶堆的优先队列：**
  1. 最小的两个出队，并合并为x
  2. 将x入队
  3. 重复1、2，直到只剩一个，**但要注意，这最后一个是总的质量，而不是带权路径长度（最小的体力消耗），所以需要一个ans变量累加每一步的体力消耗**

* 最终的体力消耗值 = 叶子结点的总质量 + 某些果堆被重复计算的质量 > 叶子结点总质量

* 正确答案：

```
#include<cstdio> 
#include<queue>

using namespace std;

//小顶堆 
priority_queue<long long, vector<long long>, greater<long long> > pq;

int main(){
	pq.push(1);
	pq.push(2);
	pq.push(9);
	long long ans = 0;      //ans必须初始化为0，否则也会出错！！
	while(pq.size() > 1){
		long long a = pq.top();
		pq.pop();
		long long b = pq.top();
		pq.pop();
		pq.push(a+b);
		ans += a+b;//这一句必须要，队列（堆）中最后一个元素仅仅是质量和而已,不能直接弹出作为答案
	}
	printf("%lld\n",ans);
	return 0;
}
```

* **错误答案一：未初始化ans**

```C++
	long long ans；
	while(pq.size() > 1){
		long long a = pq.top();
		pq.pop();
		long long b = pq.top();
		pq.pop();
		pq.push(a+b);
		ans += a+b;//这一句必须要，队列（堆）中最后一个元素仅仅是质量和而已,不能直接弹出作为答案
	}
	printf("%lld\n",ans);
```

* **错误答案二、直接取堆顶元素作为答案**

```C++
	while(pq.size() > 1){
		long long a = pq.top();
		pq.pop();
		long long b = pq.top();
		pq.pop();
		pq.push(a+b);
	}
	long long ans = pq.top();  //×
	printf("%lld\n",ans);
```

##二、哈夫曼编码（以每个字符出现的次数作为哈夫曼树叶子结点的权值，可得最短编码长度）

* 树形编码基本规则（了解即可）：
  1. 所有的左分支都标记为0，右分支都标记为1
  2. 叶子结点表示一个字符，其编码为：从根结点到它的路径上的0、1串
  3. 每个非叶子结点，一定是某个叶子结点的前缀
  4. 每个叶子结点，一定不能是其他叶子结点的前缀

* 前缀编码：任何一个字符的编码都不是另一个字符的编码的前缀

* 对于给定字符串，如"ABSABSCAABBD"，要求长度最短的前缀编码的**长度**：
  * **解法：****以每个字符出现的次数作为叶子结点的权值**，然后套用哈夫曼树的思想解决

* 只要记住标题扩号内的一句话即可

* 看看邓俊辉P114编码树、P136Huffman编码提供了完整的构造编码树的方法步骤及代码

* 解码方法很简单，只要逐个扫描编码后的二进制串，根据二进制位逐渐深入二叉树。找到叶子节点对应的字符。