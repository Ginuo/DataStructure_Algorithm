##一、分治

* 分治法：
  将原问题划分成若干个规模较小而**结构与原问题相同或相近的子问题**，然后分别解决这些问题，最后**合并子问题的解**，即可得到原问题的解。

* 子问题应当是相互独立、没有交叉的
* 分治法作为一种算法思想，既可以用递归实现，也可以用非递归的方式实现

##二、递归（Factorial）

* 重要特点：反复调用自身，但每次都把范围缩小，**直到可以直接得到边界数据的结果**

* 递归边界和递归表达式是关键

* 深度过大可能爆栈

* **如果递归函数是没有返回值的**，递归边界中可使用return语句返回（不加参数）
  不过`if 边界 else 递归表达式`其边界中不需要显式return（因为满足了边界时就不会执行递归表达式了）

* **怎么写**：
  写递归时，先把问题换成数学表达
  1. **先找出可以直接求解的边界情况**
  2. **找出某一项与上一项或上两三项的关系，方便确定递归表达式**

* 一般结构：

```C
int f(int n){
	if(..) return..   //递归边界
	else return 递归表达式
}
```

* 阶乘：（定义0的阶乘为1，作为边界）

```C
int fac(int n){
	if(n == 0){
		//递归边界 
		return 1;      //0的阶乘为1 
	}else{
		return n * fac(n-1);
	}
} 
```

* Fibonacci数列第n项：

```C
{
	if(n == 0)  
		return 1;
	else if(n==1)
		return 1;
	else
		return fib(n-1) + fib(n-2); 
}
```



##三、全排列问题(Full Permutation)

* 全排列：n个元素所能形成的顺序不同的所有排列
  如1、2、3的全排列是这6个排列：
  `123  132  213  231  312  321`

* n个元素的全排列共包括**n!**（n的阶乘）个排列

* 问题要求：
  按字典序从小到大输出数字1~n的全排列

```C++
（1）子问题：
	输出以1开头的全排列
	输出以2开头的全排列
	......
	输出以3开头的全排列
（2）递归边界：已经处理完了排列的1~n位（生成了一个排列）
（3）递归式：generateP(index+1)
```
```C++
#include<cstdio>

const int maxn = 10;
int n;         //对从1到n的数字排列 
int P[maxn];    //记录当前这一个排列，第一位闲置 
bool hashTable[maxn] = {false};   //散列数组，判断数字是否已在排列中 

//没有返回值的递归函数！使用return返回 
/*
特殊的是：generateP函数的参数index，初始值为1， 
         index随着递归深度增加而增加（而fabonacci数列的参数是递减的） 
*/
void generateP(int index){
	if(index == n+1){       //***递归边界，已经处理完排列的第1~n位 
		for(int i = 1; i <= n; i++){
			printf("%d",P[i]);
		}
		printf("\n");
		return ;       //空的返回 
	} 
	/*
	核心代码也就下面这个for循环，以上的几行都是处理边界情况，不需要刻意记
	下面几行实在不行就背下来
	*/ 
	for (int x = 1; x <= n; x++){      //枚举1~n，每个for循环生成以x开头的所有排列 
		if(hashTable[x] == false){
			P[index] = x;            //如果x不在数组（即排列）中，将其加入数组 
			hashTable[x] = true;
			generateP(index + 1);     //处理当前排列的下一位
			hashTable[x] = false;       //已处理完P[index]为x的子问题，还原状态  
			                            //**同层其他**递归过程还要使用（保证子问题的独立性） 
		}
	} 
}

int main(){
	n = 3;    //输出从1-3的全排列
	generateP(1);      //**注意：参数不是n，是1     表示从1开始
	return 0; 
}
```

##四、N皇后问题

* 问题描述：在一个n×n的棋盘上放置n个皇后，要求两两不在同一行、同一列、同一条对角线（对角线不止两条，此处的对角线是指棋盘上所有45°和135°的线），求合法的方案数。

####4.1 暴力法解决（并不是遍历很多）

* 思路：
  1. 每一行的皇后所在的列号依次写出，会是1~n的一个排列
  2. 生成1~n的全排列
  3. 因为每到达一次递归边界，就生成了一个排列，
   所以在递归边界对当前排列中的**任意**两个皇后是否在一条对角线进行判断即可


* **关键**在于如何判断是否在同一对角线：
  **只要两个皇后之间的行距和列距相等**（即连线的斜率的绝对值为1），就在同一对角线

```C++
const int maxn = 11;        //任意一个比较小的数字都行 
int n;
int count = 0;       //计数器，记录有多少个合法排列 
int P[maxn];
bool hashTable[maxn] = {false};


void generateP(int index){
	if (index == n+1){
		bool flag = true;             //flag用于判断是否合法，是计数器的依据 
		//***核心代码：判断是否有皇后在同一条对角线*** 
		for(int i = 1; i <= n; i++){
			for(int j = i+1; j <= n; j++){
				//***只要两个皇后之间的连线的斜率的绝对值为1，就说明在同一对角线上 
				//***或者说，只要两个皇后的行距和列距相等，就在同一对角线上 
				if(abs(i-j) == abs(P[i] - P[j]))
					flag = false;        //有皇后在同一对角线上，不合法，不计入 
			}
		} 
		if(flag) count++;
		return;             //***一定要记得return！！！ 
	}
	
	for(int x = 1; x <= n; x++){
		if(hashTable[x] == false){
			P[index] = x;
			hashTable[x] = true;
			generateP(index+1);
			hashTable[x] = false;
		}
	}
}

int main(){
	n = 5;
	generateP(1);



	return 0;
} 
```

####4.2 回溯法解决

* 回溯法：在到达递归边界前的某一层，由于一些事实导致已经不需要往任何一个问题递归，就可以直接返回上一层，这种方法叫回溯法

* 书上的代码执行不对，