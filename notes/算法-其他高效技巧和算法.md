##打表

* 事先计算出可能用到的结果，具体类型有：
  1. 一次性计算出所有需要用到的结果，之后的查询直接取这些结果
  2. 在程序B中分一次或多次计算出所有可能用到的结果，手工把结果写在程序A的数组中，然后在程序A中可以直接使用这些结果
  3. 对一些感觉不会做的题目，先用暴力程序计算出小范围的结果，然后找规律

##活用递推

* 尤其对于涉及序列的题目来说，要认真考虑某一位能否通过其他位递推得到

* **PAT_A1093**

* 书本P148，有一种解法

* 我的解法：
  * **对每一个确定位置的A来说，以它形成的PAT的个数等于他左边的P的个数与右边的T的个数的乘积**
  
  * 比如对于"APPAPT"，第一个A，左边有0个P，右边有1个T；第二个A，左边有2个P，右边有1个T；所以总共能形成(0×1+2×1)=2个PAT
  
  * 将所有的A抽象成一个**结构体数组**，每个元素对应一个A，结构体中有**leftP和rightT**两个变量，记录每个A两边的P和T的个数。


* **注意！！！**：记得取余数，而且必须对ans的每一个中间结果都取，而不仅是对最终结果取,这应该形成习惯，**很多题目都要注意类似的问题**！！

* 两种思路其实类似，只是对P和T的个数的保存方式不同，书上的解法更加体现递推的活用

```C++
#include<cstdio>
#include<cstring>

const int MOD = 1000000007; 
const int maxn = 100001; 

struct A{        //每个元素表示一个A 
	int leftP;         //该A左边的P的个数 
	int rightT;        //右边的T的个数 
} a[maxn];


int main(){
  char str[maxn];
  gets(str);
  int len = strlen(str);

  int p = 0;      //记录P的个数 
  int t = 0;      //记录T的个数 
  int index = 0;      //结构体数组的索引 
  //从左往右扫描，对'P'计数 
  for(int i = 0; str[i] != '\0'; i++){
    if(str[i] == 'P'){       
      p++;
    }
    else if(str[i] == 'A'){ //遇到一个A，就把它左边的P的个数记录到结构体 
      a[index++].leftP = p;
    }
  }
  //从右往左扫描，对'T'计数 
  int x = index;
  for(int i = len - 1; i >= 0; i--){
    if(str[i] == 'T')
      t++;
    else if(str[i] == 'A') //遇到一个A，就把它右边的T的个数记录到结构体 
      a[--x].rightT = t;  
  
  }
  
  int ans = 0;
  for(int i = 0; i < index; i++){
    //****一定要在这里对每一步取余，而不是仅在输出前对最终结果取！！
	//****因为中间结果也可能溢出！！
    ans = (ans + a[i].leftP * a[i].rightT) % MOD;
  }
  printf("%d\n",ans);            //ans % MOD 不能写在这里 
  return 0;
} 
```

##随机选择算法

* 基本问题描述：
  从一个无序数组中找出第K大的数（在不对所有数据排序的情况下）

* **思路：**
  1. 对a[left,right]执行一次切分（随机快排中的算法），得到切分元素的绝对位置p
     切分元素就是子序列中第M大的元素(M = p - left + 1)
  2. **如果a[p]正好是第K大的数(即 K == M时)，返回a[p]**
  3. 如果K > M，即第K大的数比a[p]更大，在a[p]右边，那么递归地在[p+1,right]中寻找第
     K-M大的元素
  4. 如果K < M，即第K大的数小于a[p]，那么递归地在[left,p-1]中寻找第K大的元素
  5. 递归边界：left == right时，也就是查询的最坏情况时，等于对所有元素排好了序，**最后一个被排序元素才是第K大元素，返回a[left]**
 

* **递归边界虽然很少执行到，但是必须写！！**，如果没有这一行，对于仅有一个元素的数组将    会出错

```C++
//重点注意两个return，第K大元素可能从两个地方返回 
int randSelect(int a[], int left, int right, int K){   //k也是相对的
	if(left == right) 	return a[left];     //返回第K大元素 **最坏情况，容易漏写！！ 
	int p = randPartition(a,left,right);  //调用切分，返回切分元素的位置 
	int M = p - left + 1;             //M是切分元素在子数组中的相对位置，pos才是在整个数组的绝对位置
	if(K == M)	return a[p];          //切分元素正好是第K大元素时返回  
	if(K > M)
		return randSelect(a, p+1, right, K-M);      //K>M时，查找右边的第K-M大元素 
	else
		return randSelect(a, left, p-1, K);        //K<M时，查找左边的第K大元素 
	
}
```

###随机选择算法的例题

* 题目描述：给定整数集合，集合中整数各不相同，要求将他划分成两个子集（并为原集，交为空），两个子集的元素个数n1与n2之差的绝对值|n1-n2|尽可能小的前提下，要求他们各自的**元素之和**S1和S2之差的绝对值|S1-S2|尽可能大，求|S1-S2|？

* 分析：
  1. 如果原集合元素个数n是偶数，**找出第n/2大的元素**，只要较大的n/2个元素全在子集A中，较小的n/2个元素全在子集B中即可
  2. 如果原集合元素个数n是奇数，只要找出**第n/2大的元素**，让所有小于等于它的元素全在集合A，所有大于它的元素全在集合B中


* 也可以使用排序的办法解决(O(nlogn))，排好序后，把a[0] ~ a[n/2 - 1]放入一个集合，a[n/2] ~ a[n-1]放入另一个集合

* 用随机选择算法解决，期望时间复杂度为O(n)，只要找出第n/2大的元素就行了

####还没做，留待...，代码在书上P150