##一、贪心

* 所谓贪心算法是指，在对问题求解时，总是做出**在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。

* 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，**选择的贪心策略必须具备无后效性**，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。

* 贪心策略适用的**前提**是：局部最优策略能导致产生全局最优解。

### 例题见PAT B1020（已做）、B1023（未做）


##二、区间贪心

###2.1 区间不相交问题

* **描述：**给出N个开区间（x,y），从中选出尽可能多的开区间，使得两两均不相交

* 输入格式：

```
N            //N个区间
x1,y1
x2,y2
...
xn,yn         //N个区间的左右端点
```

* 输出最多的区间数

* 思路：
  1. 先按左端点从大到小排序，左端点相同的按右端点从小到大排序
  2. 总是先选择左端点最大的区间，然后依次比较该区间左端点(记为lastX)与其（右方）邻近区间的右端点是否相交
  3. 若不相交，则计数器加1，然后以新找到的区间的左端点作为新的lastX,重复第2步

```C++
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn = 100;

struct Inteval{
	int x,y;      //开区间左右端点 
} I[maxn]; 

//左端点不等时，按左区间从大到小排序；左端点不等时，按右端点从小到大排序 
bool cmp(Inteval a, Inteval b){
	if(a.x != b.x)
		return a.x > b.x;
	else
		return a.y < b.y;
}

int main(){
	int n;
	scanf("%d",&n);
	for(int i = 0; i < n; i++){
		scanf("%d%d",&I[i].x, &I[i].y);
	}
	//**
	sort(I, I+n, cmp);
	
	int ans = 1;     //不相交区间个数（至少为1,为1时表示没有不相交的区间）
	int lastX = I[0].x;     //上一个被选中区间的左端点
	//遍历除左端点最大的区间外的所有区间（左端点在I[0]右边的区间） 
	for(int i = 1; i < n; i++){      
		if(I[i].y <= lastX){        //找到了一个不相交区间 
			lastX = I[i].x;
			ans++;
		}
	} 
	printf("%d\n",ans);
	return 0;
}
```

###2.2 区间选点问题

* 描述：给出N个**闭区间**[x,y]，求最少需要确定多少个点，能使得每个区间中都至少存在一个点

* 思路：
  其实就相当于将区间不相交问题中的开区间改成闭区间。
  **只需要在找出的每个不相交区间中分别取一个点即可**，其他区间都与这几个互不相交区间相交，必定能找出共同的交点

* 代码修改

```
把区间不相交问题中的 I[i].y <= lastX  改成  I[i].y < lastX
```