##定义、术语

* 每条边（Edge）的两端必须是两个顶点（Vertex）

* G(V,E)表示图G（的顶点集和边集）

* 有向图：每条边都有方向，只能从某一点到某一点
* 无向图：没条边都是双向的，连接的两个顶点可以互相到达
  在一些问题中，可以把无向图当做所有边都是正向和负向的两条有向边组成

* **顶点的度**：相连的边数，也可分为**出度、入度**

* **点权、边权：**顶点和边的某些量化的属性

##图的存储

###一、邻接矩阵（二维数组）

* 令图G(V,E)的N个顶点编号为：0、1、2···N-1，则可令二维数组`G[N][N]`的两维下标分别表示**两个顶点**

* 数组元素`G[i][j]`的值可以有两种设置方法（第二种较常用）：
  1. 非0即1，值为1表示顶点i、j之间有边，值为0表示顶点i、j之间没有边
  2. **`G[i][j]`也常用来表示顶点i、j之间的边的权值，若i、j之间不存在边，可以让`G[i][j]`为一个很大的数**（如0x3fffffff 、 10亿）

* 邻接矩阵只适用于顶点数目较少的题目（一般不超过1000）

* 注意：**无向边要存储两次，G[i][j]、G[j][i]**

###二、邻接表（通常用vector数组实现即可）

* 每个vector用于存放每个顶点的所有**出边**（只需要出边，入边也就是其他顶点的出边），Adj数组就是所有顶点的出边表的集合


* 一、如果只需要存放每条边的终点编号：`vector<int> Adj[N];`； 
  `起点编号=第一维索引，终点编号=数组元素值（不是第二维索引）`


* 二、如果要**同时存放结点编号和边权**：使用Node，见下方代码
  **（vector数组的第二维是无法作为编号的**，它总是从0开始，所以要将编号存储在结构体中）
  `起点编号=第一维索引； 终点编号=数组元素中的vertex成员`


* 注意：**无向边要存储两次（双向）**

```C++
struct Node{
	int vertex;    //结点编号Vertex（vector数组的第二维是无法作为编号的，它总是从0开始，所以要将编号存储在结构体中）
	int w;    //边权 
	Node(int _v, int _w):vertex(_v),w(_w){}     //构造函数 
}; 

vector<Node> Adj[100];

int main(){
	//有向边只需要push_back一次，从0到3 
	Adj[0].push_back(Node(3,100));
	//如果是无向边，还要反向存储一次,从3到0 
	Adj[3].push_back(Node(0,100)); 
	return 0;
} 
```